"""
src/php/php_db_lookup.py
========================
Grep-based PHP code intelligence layer.

Replaces CodeQLDBLookup for PHP analysis. Instead of querying CSV files
generated by CodeQL, this module reads PHP source files directly from the
filesystem and extracts code structures via regex and a brace-depth state
machine.

Provides the same logical interface as CodeQLDBLookup so LLMAnalyzer
receives identical tool-call results regardless of language backend.

Public API (mirrors CodeQLDBLookup):
  get_function_by_name(name)      → (code_str, meta_dict)
  get_caller_function(function_id)→ (code_str, meta_dict)
  get_class(class_name)           → (code_str, meta_dict)
  get_global_var(var_name)        → (code_str, meta_dict)
  get_macro(constant_name)        → (code_str, meta_dict)  [PHP: define/const]
  read_file_lines(path, start, end) → numbered_code_str
  find_function_by_line(path, line) → (code_str, meta_dict)
"""

import re
from pathlib import Path
from typing import Optional

# ─── Vendor directory names to skip during rglob ─────────────────────────────
_VENDOR_SKIP = frozenset({
    "node_modules", ".git", "vendor", "__MACOSX",
    ".svn", ".hg", "bower_components",
})

# ─── PHP function/method definition pattern ──────────────────────────────────
# Groups: modifiers (optional), name
# Handles: public/private/protected/static/abstract/final in any order,
#          reference return (&), PHP 8 readonly, async (future-proofed).
_FUNC_DEF_RE = re.compile(
    r'^(?P<indent>[ \t]*)'
    r'(?P<modifiers>(?:(?:public|private|protected|static|abstract|final|readonly|async)\s+)*)'
    r'function\s+'
    r'(?:&\s*)?'
    r'(?P<name>[a-zA-Z_\x7f-\xff][a-zA-Z0-9_\x7f-\xff]*)'
    r'\s*\(',
    re.MULTILINE,
)

# ─── Class/interface/trait/enum definition pattern ───────────────────────────
_CLASS_DEF_RE = re.compile(
    r'^[ \t]*(?:(?:abstract|final|readonly)\s+)*'
    r'(?P<kind>class|interface|trait|enum)\s+'
    r'(?P<name>[a-zA-Z_\x7f-\xff][a-zA-Z0-9_\x7f-\xff]*)',
    re.MULTILINE,
)

# ─── PHP constant patterns ───────────────────────────────────────────────────
_DEFINE_RE = re.compile(
    r"define\s*\(\s*['\"](?P<name>[A-Za-z_][A-Za-z0-9_]*)['\"]"
    r"\s*,\s*(?P<value>[^)]+)\)",
    re.MULTILINE,
)
_CLASS_CONST_RE = re.compile(
    r'(?:(?:public|protected|private)\s+)?const\s+'
    r'(?P<name>[A-Za-z_][A-Za-z0-9_]*)\s*=\s*(?P<value>[^;]+);',
    re.MULTILINE,
)

# Maximum lines to return for a single class body before switching to skeleton
_CLASS_SKELETON_THRESHOLD = 200


class PHPDBLookup:
    """
    Filesystem-based PHP code lookup. All methods return (code_str, meta_dict)
    matching the CodeQLDBLookup interface expected by LLMAnalyzer tool handlers.

    meta_dict keys match the CSV column names from the corresponding CodeQL
    tool queries so downstream code (IssueAnalyzer, LLMAnalyzer) requires
    zero changes:
      function: function_name, file, start_line, end_line, function_id, caller_id
      class:    type, class_name, file, start_line, end_line, simple_name
      global:   global_var_name, file, start_line, end_line
      macro:    macro_name, body
    """

    def __init__(self, plugin_dir: str):
        self.plugin_dir = Path(plugin_dir)
        self._file_cache: dict[str, str] = {}

    # =========================================================================
    # Public API
    # =========================================================================

    def get_function_by_name(self, function_name: str) -> tuple[str, dict]:
        """
        Find and return a named PHP function or method by searching all PHP
        files in plugin_dir. Returns the first match.

        Returns (code_str, meta_dict) or ("", {}) if not found.
        """
        clean_name = function_name.strip().lstrip("$")
        for php_file in self._iter_php_files():
            content = self._read(str(php_file))
            result = self._extract_named_function(content, clean_name, str(php_file))
            if result:
                return result
        return ("", {})

    def get_caller_function(self, function_id: str) -> tuple[str, dict]:
        """
        Find the enclosing function at the call site identified by function_id.
        function_id format: "/abs/path/to/file.php:LINE" (matches FunctionTree.ql).

        Strips surrounding quote characters that CodeQL CSVs add.
        Returns (code_str, meta_dict) or ("", {}) if not resolvable.
        """
        fid = function_id.strip().strip('"\'')
        if not fid or ':' not in fid:
            return ("", {})
        # Split on last colon to handle Windows absolute paths
        parts = fid.rsplit(':', 1)
        if len(parts) != 2:
            return ("", {})
        filepath, line_str = parts
        try:
            line_no = int(line_str)
        except ValueError:
            return ("", {})
        return self.find_function_by_line(filepath, line_no)

    def get_class(self, class_name: str) -> tuple[str, dict]:
        """
        Find a PHP class, interface, trait, or enum by name.
        Strips namespace prefix (searches by simple name).

        Returns (code_str, meta_dict) or ("", {}) if not found.
        Large classes (>{threshold} lines) return a skeleton with method signatures.
        """
        simple = class_name.strip().split('\\')[-1].strip().strip('"\'')
        if not simple:
            return ("", {})

        pattern = re.compile(
            r'^[ \t]*(?:(?:abstract|final|readonly)\s+)*'
            r'(?P<kind>class|interface|trait|enum)\s+'
            r'(?P<name>' + re.escape(simple) + r')\b',
            re.MULTILINE,
        )

        for php_file in self._iter_php_files():
            content = self._read(str(php_file))
            m = pattern.search(content)
            if not m:
                continue
            start_line = content[:m.start()].count('\n') + 1
            brace_pos = content.find('{', m.end())
            if brace_pos == -1:
                continue
            try:
                end_pos = self._brace_end(content, brace_pos)
            except ValueError:
                continue
            end_line = content[:end_pos].count('\n') + 1
            span = end_line - start_line

            if span > _CLASS_SKELETON_THRESHOLD:
                code = self._class_skeleton(
                    content, m.start(), brace_pos, end_pos,
                    str(php_file), start_line
                )
            else:
                code = self.read_file_lines(str(php_file), start_line, end_line)

            meta = {
                "type": m.group('kind').capitalize(),
                "class_name": simple,
                "file": str(php_file),
                "start_line": str(start_line),
                "end_line": str(end_line),
                "simple_name": simple,
            }
            return (code, meta)

        return ("", {})

    def get_global_var(self, var_name: str) -> tuple[str, dict]:
        """
        Find a PHP global variable.
        Searches for `global $name` declarations and top-level `$name =` assignments.

        Returns (code_str, meta_dict) or ("", {}) if not found.
        """
        name = var_name.strip().lstrip('$').strip('"\'')
        if not name:
            return ("", {})

        # `global $name` inside functions, or top-level `$name =`
        pattern = re.compile(
            r'(?:'
            r'(?:^|\s)global\s+(?:[^;,\n]*,\s*)?\$' + re.escape(name) + r'\b'
            r'|'
            r'(?:^|\n)\$' + re.escape(name) + r'\s*='
            r')',
            re.MULTILINE,
        )

        for php_file in self._iter_php_files():
            content = self._read(str(php_file))
            m = pattern.search(content)
            if not m:
                continue
            line_no = content[:m.start()].count('\n') + 1
            snippet = self.read_file_lines(str(php_file), max(1, line_no - 2), line_no + 4)
            meta = {
                "global_var_name": f"${name}",
                "file": str(php_file),
                "start_line": str(line_no),
                "end_line": str(line_no),
            }
            return (snippet, meta)

        return ("", {})

    def get_macro(self, constant_name: str) -> tuple[str, dict]:
        """
        PHP has no preprocessor macros. Maps to define() constants and class
        constants (const NAME = ...).

        Returns (code_str, meta_dict). If not found, returns a graceful
        informational string — LLMAnalyzer handles empty/informational tool results.
        """
        name = constant_name.strip().strip('"\'')
        if not name:
            return ("// No constant name provided", {"macro_name": "", "body": ""})

        for php_file in self._iter_php_files():
            content = self._read(str(php_file))

            # define('NAME', value)
            for m in _DEFINE_RE.finditer(content):
                if m.group('name') == name:
                    line_no = content[:m.start()].count('\n') + 1
                    body = f"define('{name}', {m.group('value').strip()});"
                    return (body, {"macro_name": name, "body": body,
                                   "file": str(php_file), "start_line": str(line_no)})

            # const NAME = value;
            for m in _CLASS_CONST_RE.finditer(content):
                if m.group('name') == name:
                    line_no = content[:m.start()].count('\n') + 1
                    body = f"const {name} = {m.group('value').strip()};"
                    return (body, {"macro_name": name, "body": body,
                                   "file": str(php_file), "start_line": str(line_no)})

        msg = (
            f"// PHP constant '{name}' not found.\n"
            f"// PHP has no preprocessor macros — searched define() and const declarations."
        )
        return (msg, {"macro_name": name, "body": msg})

    def read_file_lines(self, filepath: str, start_line: int, end_line: int) -> str:
        """
        Read a line range from a PHP file and return numbered lines.
        1-indexed, inclusive range.

        Direct filesystem replacement for Vulnhalla's read_file_lines_from_zip().
        """
        content = self._read(filepath)
        if not content:
            return f"// Could not read: {filepath}"
        lines = content.splitlines()
        start = max(0, start_line - 1)
        end = min(len(lines), end_line)
        return "\n".join(
            f"{start_line + i:5d} | {line}"
            for i, line in enumerate(lines[start:end])
        )

    def find_function_by_line(self, filepath: str, target_line: int) -> tuple[str, dict]:
        """
        Find the smallest PHP function or method that encloses target_line.

        Used by get_caller_function() and PHPIssueAnalyzer to provide the
        LLM with the enclosing function context for a taint sink or source.

        Returns (code_str, meta_dict) or ("", {}) if not found.
        """
        content = self._read(filepath)
        if not content:
            return ("", {})

        best: Optional[dict] = None
        best_span = float('inf')

        for m in _FUNC_DEF_RE.finditer(content):
            func_name = m.group('name')
            func_start_pos = m.start()
            func_start_line = content[:func_start_pos].count('\n') + 1

            brace_pos = self._find_opening_brace(content, m.end() - 1)
            if brace_pos == -1:
                continue  # abstract/interface method — no body

            try:
                end_pos = self._brace_end(content, brace_pos)
            except ValueError:
                continue

            func_end_line = content[:end_pos].count('\n') + 1

            if func_start_line <= target_line <= func_end_line:
                span = func_end_line - func_start_line
                if span < best_span:
                    best_span = span
                    best = {
                        "function_name": func_name,
                        "file": filepath,
                        "start_line": str(func_start_line),
                        "end_line": str(func_end_line),
                        "function_id": f"{filepath}:{func_start_line}",
                        "caller_id": "",
                    }

        if not best:
            return ("", {})

        code = self.read_file_lines(
            filepath,
            int(best["start_line"]),
            int(best["end_line"]),
        )
        return (code, best)

    # =========================================================================
    # Private helpers
    # =========================================================================

    def _iter_php_files(self):
        """Yield all .php files under plugin_dir, skipping vendor directories."""
        for path in self.plugin_dir.rglob("*.php"):
            if any(part in _VENDOR_SKIP for part in path.parts):
                continue
            yield path

    def _read(self, filepath: str) -> str:
        """Read file with in-process cache. Returns empty string on OSError."""
        if filepath in self._file_cache:
            return self._file_cache[filepath]
        try:
            content = Path(filepath).read_text(errors="replace")
        except OSError:
            content = ""
        self._file_cache[filepath] = content
        return content

    def _extract_named_function(
        self, content: str, function_name: str, filepath: str
    ) -> Optional[tuple[str, dict]]:
        """
        Find the first definition of `function_name` in `content`.
        Returns (code, meta) or None.
        """
        pattern = re.compile(
            r'^(?P<indent>[ \t]*)'
            r'(?P<modifiers>(?:(?:public|private|protected|static|abstract|'
            r'final|readonly|async)\s+)*)'
            r'function\s+(?:&\s*)?'
            r'(?P<name>' + re.escape(function_name) + r')\s*\(',
            re.MULTILINE,
        )

        for m in pattern.finditer(content):
            if m.group('name') != function_name:
                continue  # Paranoia: exact match only

            func_start_line = content[:m.start()].count('\n') + 1

            brace_pos = self._find_opening_brace(content, m.end() - 1)
            if brace_pos == -1:
                continue  # Abstract method declaration

            try:
                end_pos = self._brace_end(content, brace_pos)
            except ValueError:
                continue

            func_end_line = content[:end_pos].count('\n') + 1
            code = self.read_file_lines(filepath, func_start_line, func_end_line)

            # Attempt to find one call site for caller_id
            caller_id = self._find_first_call_site(content, function_name, filepath)

            meta = {
                "function_name": function_name,
                "file": filepath,
                "start_line": str(func_start_line),
                "end_line": str(func_end_line),
                "function_id": f"{filepath}:{func_start_line}",
                "caller_id": caller_id,
            }
            return (code, meta)

        return None

    def _find_opening_brace(self, content: str, search_from: int) -> int:
        """
        Scan forward from search_from past the parameter list to find the
        function body's opening `{`.

        Returns position of `{`, or -1 if a `;` is encountered first
        (abstract/interface method with no body).
        """
        i = search_from
        paren_depth = 0
        n = len(content)

        while i < n:
            c = content[i]

            # Skip string literals
            if c in ("'", '"'):
                i = self._skip_string(content, i)
                continue

            # Skip line comments
            if c == '/' and i + 1 < n:
                if content[i + 1] == '/':
                    end = content.find('\n', i)
                    i = (end + 1) if end != -1 else n
                    continue
                if content[i + 1] == '*':
                    end = content.find('*/', i + 2)
                    i = (end + 2) if end != -1 else n
                    continue

            if c == '#' and not (i + 1 < n and content[i + 1] == '['):
                end = content.find('\n', i)
                i = (end + 1) if end != -1 else n
                continue

            if c == '(':
                paren_depth += 1
            elif c == ')':
                paren_depth -= 1
            elif c == '{' and paren_depth <= 0:
                return i
            elif c == ';' and paren_depth <= 0:
                return -1  # No function body

            i += 1

        return -1

    def _brace_end(self, content: str, brace_start: int) -> int:
        """
        Character-by-character state machine to find the matching `}` for the
        `{` at brace_start. Returns exclusive end position (pos after `}`).

        Correctly handles all PHP string delimiters and comment types:
          Single-quoted strings  'abc\\'s'
          Double-quoted strings  "Hello $name {$arr['k']}"
          Heredoc                <<<EOT ... EOT
          Nowdoc                 <<<'EOT' ... EOT
          Line comments          // ...   # ... (not #[)
          Block comments         /* ... */
          PHP 8 attributes       #[Attribute]  — NOT treated as comments

        Raises ValueError on unbalanced braces.
        """
        assert content[brace_start] == '{', (
            f"Expected '{{' at {brace_start}, got {content[brace_start]!r}"
        )

        i = brace_start
        depth = 0
        n = len(content)

        while i < n:
            c = content[i]

            # ── Single-quoted string ──────────────────────────────────────────
            if c == "'":
                i += 1
                while i < n:
                    if content[i] == '\\' and i + 1 < n:
                        i += 2
                        continue
                    if content[i] == "'":
                        i += 1
                        break
                    i += 1
                continue

            # ── Double-quoted string ──────────────────────────────────────────
            if c == '"':
                i += 1
                while i < n:
                    if content[i] == '\\' and i + 1 < n:
                        i += 2
                        continue
                    if content[i] == '"':
                        i += 1
                        break
                    i += 1
                continue

            # ── Heredoc / Nowdoc ──────────────────────────────────────────────
            if c == '<' and content[i:i + 3] == '<<<':
                i += 3
                while i < n and content[i] == ' ':
                    i += 1
                is_nowdoc = (i < n and content[i] == "'")
                if is_nowdoc:
                    i += 1  # skip opening quote
                label_start = i
                while i < n and content[i] not in ('\n', "'", '"', ' ', '\t'):
                    i += 1
                label = content[label_start:i]
                if is_nowdoc and i < n and content[i] == "'":
                    i += 1  # skip closing quote
                # Skip rest of opener line
                while i < n and content[i] != '\n':
                    i += 1
                i += 1  # past newline
                # Scan for end label at start of line
                while i < n:
                    line_end = content.find('\n', i)
                    if line_end == -1:
                        line_end = n
                    line_text = content[i:line_end].rstrip()
                    if line_text == label or line_text == label + ';':
                        i = line_end + 1
                        break
                    i = line_end + 1
                continue

            # ── Line comment // ───────────────────────────────────────────────
            if c == '/' and i + 1 < n and content[i + 1] == '/':
                end = content.find('\n', i)
                i = (end + 1) if end != -1 else n
                continue

            # ── PHP 8 attribute #[ — do NOT treat as comment ─────────────────
            if c == '#' and i + 1 < n and content[i + 1] == '[':
                # Let the `[` and `]` be processed normally; just advance past `#`
                i += 1
                continue

            # ── Line comment # ────────────────────────────────────────────────
            if c == '#':
                end = content.find('\n', i)
                i = (end + 1) if end != -1 else n
                continue

            # ── Block comment /* ──────────────────────────────────────────────
            if c == '/' and i + 1 < n and content[i + 1] == '*':
                end = content.find('*/', i + 2)
                i = (end + 2) if end != -1 else n
                continue

            # ── Brace depth ───────────────────────────────────────────────────
            if c == '{':
                depth += 1
            elif c == '}':
                depth -= 1
                if depth == 0:
                    return i + 1  # exclusive end position

            i += 1

        open_line = content[:brace_start].count('\n') + 1
        raise ValueError(
            f"Unbalanced PHP braces: opening '{{' at line {open_line} "
            f"(pos {brace_start}) has no matching '}}'"
        )

    def _skip_string(self, content: str, pos: int) -> int:
        """Skip past a string literal at `pos`. Returns new position."""
        quote = content[pos]
        i = pos + 1
        n = len(content)
        while i < n:
            if content[i] == '\\' and i + 1 < n:
                i += 2
                continue
            if content[i] == quote:
                return i + 1
            i += 1
        return n

    def _find_first_call_site(
        self, content: str, function_name: str, filepath: str
    ) -> str:
        """
        Find the first call site for function_name in content.
        Returns "filepath:line" matching FunctionTree.ql caller_id format, or "".
        Excludes the definition line itself by matching `name(` not preceded by
        the word `function`.
        """
        # Negative lookbehind: not preceded by `function ` (with arbitrary spaces)
        call_re = re.compile(
            r'(?<!\bfunction\s{0,30})\b'
            + re.escape(function_name)
            + r'\s*\(',
        )
        for m in call_re.finditer(content):
            # Simple proximity check: is `function` in the preceding 40 chars?
            pre = content[max(0, m.start() - 40):m.start()]
            if re.search(r'\bfunction\s*$', pre):
                continue
            line_no = content[:m.start()].count('\n') + 1
            return f'"{filepath}:{line_no}"'
        return '""'

    def _class_skeleton(
        self,
        content: str,
        class_start: int,
        brace_start: int,
        brace_end: int,
        filepath: str,
        start_line: int,
    ) -> str:
        """
        For classes exceeding _CLASS_SKELETON_THRESHOLD lines, emit the class
        header plus a list of method signatures with line numbers.
        Avoids saturating the LLM context window with large class bodies.
        """
        header = content[class_start:brace_start + 1]
        header_line_count = header.count('\n')
        body = content[brace_start + 1:brace_end - 1]

        sigs = []
        for m in _FUNC_DEF_RE.finditer(body):
            line_offset = body[:m.start()].count('\n')
            abs_line = start_line + header_line_count + line_offset
            modifiers = m.group('modifiers').strip()
            name = m.group('name')
            prefix = f"{modifiers} function" if modifiers else "function"
            sigs.append(f"    {prefix} {name}(...)  // line {abs_line}")

        header_str = "\n".join(
            f"{start_line + i:5d} | {line}"
            for i, line in enumerate(header.splitlines())
        )
        methods_str = "\n".join(sigs)
        total = len(sigs)
        return (
            f"{header_str}\n"
            f"    // [Class body truncated — {total} methods; "
            f"request individual methods by name]\n"
            f"{methods_str}\n}}"
        )
